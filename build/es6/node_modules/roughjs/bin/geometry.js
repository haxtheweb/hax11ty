export function rotatePoints(t,n,o){if(t&&t.length){const[e,r]=n,i=Math.PI/180*o,c=Math.cos(i),a=Math.sin(i);t.forEach((t=>{const[n,o]=t;t[0]=(n-e)*c-(o-r)*a+e,t[1]=(n-e)*a+(o-r)*c+r}))}}export function rotateLines(t,n,o){const e=[];t.forEach((t=>e.push(...t))),rotatePoints(e,n,o)}export function lineLength(t){const n=t[0],o=t[1];return Math.sqrt(Math.pow(n[0]-o[0],2)+Math.pow(n[1]-o[1],2))}export function lineIntersection(t,n,o,e){const r=n[1]-t[1],i=t[0]-n[0],c=r*t[0]+i*t[1],a=e[1]-o[1],s=o[0]-e[0],u=a*o[0]+s*o[1],h=r*s-a*i;return h?[(s*c-i*u)/h,(r*u-a*c)/h]:null}export function isPointInPolygon(t,n,o){const e=t.length;if(e<3)return!1;const r=[Number.MAX_SAFE_INTEGER,o],i=[n,o];let c=0;for(let n=0;n<e;n++){const o=t[n],a=t[(n+1)%e];if(doIntersect(o,a,i,r)){if(0===orientation(o,i,a))return onSegment(o,i,a);c++}}return c%2==1}function onSegment(t,n,o){return n[0]<=Math.max(t[0],o[0])&&n[0]>=Math.min(t[0],o[0])&&n[1]<=Math.max(t[1],o[1])&&n[1]>=Math.min(t[1],o[1])}function orientation(t,n,o){const e=(n[1]-t[1])*(o[0]-n[0])-(n[0]-t[0])*(o[1]-n[1]);return 0===e?0:e>0?1:2}export function doIntersect(t,n,o,e){const r=orientation(t,n,o),i=orientation(t,n,e),c=orientation(o,e,t),a=orientation(o,e,n);return r!==i&&c!==a||(!(0!==r||!onSegment(t,o,n))||(!(0!==i||!onSegment(t,e,n))||(!(0!==c||!onSegment(o,t,e))||!(0!==a||!onSegment(o,n,e)))))}