import{getFiller as t}from"./fillers/filler.js";import{Random as e}from"./math.js";import{parsePath as o,normalize as s,absolutize as n}from"../../path-data-parser/lib/index.js";const f={randOffset,randOffsetWithRange,ellipse,doubleLineOps:doubleLineFillOps};export function line(t,e,o,s,n){return{type:"path",ops:_doubleLine(t,e,o,s,n)}}export function linearPath(t,e,o){const s=(t||[]).length;if(s>2){const n=[];for(let e=0;e<s-1;e++)n.push(..._doubleLine(t[e][0],t[e][1],t[e+1][0],t[e+1][1],o));return e&&n.push(..._doubleLine(t[s-1][0],t[s-1][1],t[0][0],t[0][1],o)),{type:"path",ops:n}}return 2===s?line(t[0][0],t[0][1],t[1][0],t[1][1],o):{type:"path",ops:[]}}export function polygon(t,e){return linearPath(t,!0,e)}export function rectangle(t,e,o,s,n){return polygon([[t,e],[t+o,e],[t+o,e+s],[t,e+s]],n)}export function curve(t,e){let o=_curveWithOffset(t,1*(1+.2*e.roughness),e);if(!e.disableMultiStroke){const s=_curveWithOffset(t,1.5*(1+.22*e.roughness),function cloneOptionsAlterSeed(t){const e=Object.assign({},t);e.randomizer=void 0,t.seed&&(e.seed=t.seed+1);return e}(e));o=o.concat(s)}return{type:"path",ops:o}}export function ellipse(t,e,o,s,n){return ellipseWithParams(t,e,n,generateEllipseParams(o,s,n)).opset}export function generateEllipseParams(t,e,o){const s=Math.sqrt(2*Math.PI*Math.sqrt((Math.pow(t/2,2)+Math.pow(e/2,2))/2)),n=Math.max(o.curveStepCount,o.curveStepCount/Math.sqrt(200)*s),f=2*Math.PI/n;let p=Math.abs(t/2),a=Math.abs(e/2);const r=1-o.curveFitting;return p+=_offsetOpt(p*r,o),a+=_offsetOpt(a*r,o),{increment:f,rx:p,ry:a}}export function ellipseWithParams(t,e,o,s){const[n,f]=_computeEllipsePoints(s.increment,t,e,s.rx,s.ry,1,s.increment*_offset(.1,_offset(.4,1,o),o),o);let p=_curve(n,null,o);if(!o.disableMultiStroke&&0!==o.roughness){const[n]=_computeEllipsePoints(s.increment,t,e,s.rx,s.ry,1.5,0,o),f=_curve(n,null,o);p=p.concat(f)}return{estimatedPoints:f,opset:{type:"path",ops:p}}}export function arc(t,e,o,s,n,f,p,a,r){const u=t,i=e;let h=Math.abs(o/2),c=Math.abs(s/2);h+=_offsetOpt(.01*h,r),c+=_offsetOpt(.01*c,r);let l=n,_=f;for(;l<0;)l+=2*Math.PI,_+=2*Math.PI;_-l>2*Math.PI&&(l=0,_=2*Math.PI);const O=2*Math.PI/r.curveStepCount,d=Math.min(O/2,(_-l)/2),M=_arc(d,u,i,h,c,l,_,1,r);if(!r.disableMultiStroke){const t=_arc(d,u,i,h,c,l,_,1.5,r);M.push(...t)}return p&&(a?M.push(..._doubleLine(u,i,u+h*Math.cos(l),i+c*Math.sin(l),r),..._doubleLine(u,i,u+h*Math.cos(_),i+c*Math.sin(_),r)):M.push({op:"lineTo",data:[u,i]},{op:"lineTo",data:[u+h*Math.cos(l),i+c*Math.sin(l)]})),{type:"path",ops:M}}export function svgPath(t,e){const f=s(n(o(t))),p=[];let a=[0,0],r=[0,0];for(const{key:t,data:o}of f)switch(t){case"M":{const t=1*(e.maxRandomnessOffset||0),s=e.preserveVertices;p.push({op:"move",data:o.map((o=>o+(s?0:_offsetOpt(t,e))))}),r=[o[0],o[1]],a=[o[0],o[1]];break}case"L":p.push(..._doubleLine(r[0],r[1],o[0],o[1],e)),r=[o[0],o[1]];break;case"C":{const[t,s,n,f,a,u]=o;p.push(..._bezierTo(t,s,n,f,a,u,r,e)),r=[a,u];break}case"Z":p.push(..._doubleLine(r[0],r[1],a[0],a[1],e)),r=[a[0],a[1]]}return{type:"path",ops:p}}export function solidFillPolygon(t,e){const o=[];if(t.length){const s=e.maxRandomnessOffset||0,n=t.length;if(n>2){o.push({op:"move",data:[t[0][0]+_offsetOpt(s,e),t[0][1]+_offsetOpt(s,e)]});for(let f=1;f<n;f++)o.push({op:"lineTo",data:[t[f][0]+_offsetOpt(s,e),t[f][1]+_offsetOpt(s,e)]})}}return{type:"fillPath",ops:o}}export function patternFillPolygon(e,o){return t(o,f).fillPolygon(e,o)}export function patternFillArc(t,e,o,s,n,f,p){const a=t,r=e;let u=Math.abs(o/2),i=Math.abs(s/2);u+=_offsetOpt(.01*u,p),i+=_offsetOpt(.01*i,p);let h=n,c=f;for(;h<0;)h+=2*Math.PI,c+=2*Math.PI;c-h>2*Math.PI&&(h=0,c=2*Math.PI);const l=(c-h)/p.curveStepCount,_=[];for(let t=h;t<=c;t+=l)_.push([a+u*Math.cos(t),r+i*Math.sin(t)]);return _.push([a+u*Math.cos(c),r+i*Math.sin(c)]),_.push([a,r]),patternFillPolygon(_,p)}export function randOffset(t,e){return _offsetOpt(t,e)}export function randOffsetWithRange(t,e,o){return _offset(t,e,o)}export function doubleLineFillOps(t,e,o,s,n){return _doubleLine(t,e,o,s,n,!0)}function random(t){return t.randomizer||(t.randomizer=new e(t.seed||0)),t.randomizer.next()}function _offset(t,e,o,s=1){return o.roughness*s*(random(o)*(e-t)+t)}function _offsetOpt(t,e,o=1){return _offset(-t,t,e,o)}function _doubleLine(t,e,o,s,n,f=!1){const p=f?n.disableMultiStrokeFill:n.disableMultiStroke,a=_line(t,e,o,s,n,!0,!1);if(p)return a;const r=_line(t,e,o,s,n,!0,!0);return a.concat(r)}function _line(t,e,o,s,n,f,p){const a=Math.pow(t-o,2)+Math.pow(e-s,2),r=Math.sqrt(a);let u=1;u=r<200?1:r>500?.4:-.0016668*r+1.233334;let i=n.maxRandomnessOffset||0;i*i*100>a&&(i=r/10);const h=i/2,c=.2+.2*random(n);let l=n.bowing*n.maxRandomnessOffset*(s-e)/200,_=n.bowing*n.maxRandomnessOffset*(t-o)/200;l=_offsetOpt(l,n,u),_=_offsetOpt(_,n,u);const O=[],randomHalf=()=>_offsetOpt(h,n,u),randomFull=()=>_offsetOpt(i,n,u),d=n.preserveVertices;return f&&(p?O.push({op:"move",data:[t+(d?0:randomHalf()),e+(d?0:randomHalf())]}):O.push({op:"move",data:[t+(d?0:_offsetOpt(i,n,u)),e+(d?0:_offsetOpt(i,n,u))]})),p?O.push({op:"bcurveTo",data:[l+t+(o-t)*c+randomHalf(),_+e+(s-e)*c+randomHalf(),l+t+2*(o-t)*c+randomHalf(),_+e+2*(s-e)*c+randomHalf(),o+(d?0:randomHalf()),s+(d?0:randomHalf())]}):O.push({op:"bcurveTo",data:[l+t+(o-t)*c+randomFull(),_+e+(s-e)*c+randomFull(),l+t+2*(o-t)*c+randomFull(),_+e+2*(s-e)*c+randomFull(),o+(d?0:randomFull()),s+(d?0:randomFull())]}),O}function _curveWithOffset(t,e,o){const s=[];s.push([t[0][0]+_offsetOpt(e,o),t[0][1]+_offsetOpt(e,o)]),s.push([t[0][0]+_offsetOpt(e,o),t[0][1]+_offsetOpt(e,o)]);for(let n=1;n<t.length;n++)s.push([t[n][0]+_offsetOpt(e,o),t[n][1]+_offsetOpt(e,o)]),n===t.length-1&&s.push([t[n][0]+_offsetOpt(e,o),t[n][1]+_offsetOpt(e,o)]);return _curve(s,null,o)}function _curve(t,e,o){const s=t.length,n=[];if(s>3){const f=[],p=1-o.curveTightness;n.push({op:"move",data:[t[1][0],t[1][1]]});for(let e=1;e+2<s;e++){const o=t[e];f[0]=[o[0],o[1]],f[1]=[o[0]+(p*t[e+1][0]-p*t[e-1][0])/6,o[1]+(p*t[e+1][1]-p*t[e-1][1])/6],f[2]=[t[e+1][0]+(p*t[e][0]-p*t[e+2][0])/6,t[e+1][1]+(p*t[e][1]-p*t[e+2][1])/6],f[3]=[t[e+1][0],t[e+1][1]],n.push({op:"bcurveTo",data:[f[1][0],f[1][1],f[2][0],f[2][1],f[3][0],f[3][1]]})}if(e&&2===e.length){const t=o.maxRandomnessOffset;n.push({op:"lineTo",data:[e[0]+_offsetOpt(t,o),e[1]+_offsetOpt(t,o)]})}}else 3===s?(n.push({op:"move",data:[t[1][0],t[1][1]]}),n.push({op:"bcurveTo",data:[t[1][0],t[1][1],t[2][0],t[2][1],t[2][0],t[2][1]]})):2===s&&n.push(..._doubleLine(t[0][0],t[0][1],t[1][0],t[1][1],o));return n}function _computeEllipsePoints(t,e,o,s,n,f,p,a){const r=[],u=[],i=_offsetOpt(.5,a)-Math.PI/2,h=0===a.roughness;h||u.push([_offsetOpt(f,a)+e+.9*s*Math.cos(i-t),_offsetOpt(f,a)+o+.9*n*Math.sin(i-t)]);const c=2*Math.PI+(h?0:i-.01);for(let p=i;p<c;p+=t){const t=[_offsetOpt(f,a)+e+s*Math.cos(p),_offsetOpt(f,a)+o+n*Math.sin(p)];r.push(t),u.push(t)}return h||(u.push([_offsetOpt(f,a)+e+s*Math.cos(i+2*Math.PI+.5*p),_offsetOpt(f,a)+o+n*Math.sin(i+2*Math.PI+.5*p)]),u.push([_offsetOpt(f,a)+e+.98*s*Math.cos(i+p),_offsetOpt(f,a)+o+.98*n*Math.sin(i+p)]),u.push([_offsetOpt(f,a)+e+.9*s*Math.cos(i+.5*p),_offsetOpt(f,a)+o+.9*n*Math.sin(i+.5*p)])),[u,r]}function _arc(t,e,o,s,n,f,p,a,r){const u=f+_offsetOpt(.1,r),i=[];i.push([_offsetOpt(a,r)+e+.9*s*Math.cos(u-t),_offsetOpt(a,r)+o+.9*n*Math.sin(u-t)]);for(let f=u;f<=p;f+=t)i.push([_offsetOpt(a,r)+e+s*Math.cos(f),_offsetOpt(a,r)+o+n*Math.sin(f)]);return i.push([e+s*Math.cos(p),o+n*Math.sin(p)]),i.push([e+s*Math.cos(p),o+n*Math.sin(p)]),_curve(i,null,r)}function _bezierTo(t,e,o,s,n,f,p,a){const r=[],u=[a.maxRandomnessOffset||1,(a.maxRandomnessOffset||1)+.3];let i=[0,0];const h=a.disableMultiStroke?1:2,c=a.preserveVertices;for(let l=0;l<h;l++)0===l?r.push({op:"move",data:[p[0],p[1]]}):r.push({op:"move",data:[p[0]+(c?0:_offsetOpt(u[0],a)),p[1]+(c?0:_offsetOpt(u[0],a))]}),i=c?[n,f]:[n+_offsetOpt(u[l],a),f+_offsetOpt(u[l],a)],r.push({op:"bcurveTo",data:[t+_offsetOpt(u[l],a),e+_offsetOpt(u[l],a),o+_offsetOpt(u[l],a),s+_offsetOpt(u[l],a),i[0],i[1]]});return r}