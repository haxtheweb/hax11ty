/**
@license
Copyright (c) 2019 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import"./boot.js";import{wrap as e}from"./wrap.js";const o=window.ShadyDOM,t=window.ShadyCSS;function sameScope(o,t){return e(o).getRootNode()===t}export function scopeSubtree(n,r=!1){if(!o||!t)return null;if(!o.handlesDynamicScoping)return null;const c=t.ScopingShim;if(!c)return null;const s=c.scopeForNode(n),d=e(n).getRootNode(),scopify=e=>{if(!sameScope(e,d))return;const t=Array.from(o.nativeMethods.querySelectorAll.call(e,"*"));t.push(e);for(let e=0;e<t.length;e++){const o=t[e];if(!sameScope(o,d))continue;const n=c.currentScopeForNode(o);n!==s&&(""!==n&&c.unscopeNode(o,n),c.scopeNode(o,s))}};if(scopify(n),r){const e=new MutationObserver((e=>{for(let o=0;o<e.length;o++){const t=e[o];for(let e=0;e<t.addedNodes.length;e++){const o=t.addedNodes[e];o.nodeType===Node.ELEMENT_NODE&&scopify(o)}}}));return e.observe(n,{childList:!0,subtree:!0}),e}return null}