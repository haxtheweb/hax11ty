/**
@license
Copyright (c) 2017 The Polymer Project Authors. All rights reserved.
This code may only be used under the BSD style license found at http://polymer.github.io/LICENSE.txt
The complete set of authors may be found at http://polymer.github.io/AUTHORS.txt
The complete set of contributors may be found at http://polymer.github.io/CONTRIBUTORS.txt
Code distributed by Google as part of the polymer project is also
subject to an additional IP rights grant found at http://polymer.github.io/PATENTS.txt
*/
import"../utils/boot.js";import{isPath as e}from"../utils/path.js";import{dedupingMixin as t}from"../utils/mixin.js";import{PropertyEffects as r}from"./property-effects.js";const a={"{":"}","[":"]"},s=1,n=2,i=3,o=4,c=5,h=6,u=7,l=8,d=9,b=10,m=11,g=12,p=13,C=14,f=15;function pushLiteral(e,t,r,a){const s=e.substring(a||0,t);s&&r.push({literal:s})}function storeMethod(e,t){const r=e.signature.methodName,a=t.dynamicFns;(a&&a[r]||e.signature.static)&&(e.dependencies.push(r),e.signature.dynamicFn=!0)}function storeVariableBinding(e,t,r,a){t.source=r,t.dependencies.push(r),t.startChar=a+1,e.push(t)}function storeMethodVariable(t,r,a){const s=r.substring(t.startChar,a).trim();if(s)if("true"===s||"false"===s)t.signature.args.push({name:s,value:"true"==s,literal:!0});else{const r={name:s};r.structured=e(s),r.structured&&(r.wildcard=".*"==s.slice(-2),r.wildcard&&(r.name=s.slice(0,-2))),t.signature.args.push(r),t.dependencies.push(s),t.signature.static=!1}}function storeMethodNumber(e,t,r){const a=t.substring(e.startChar,r).trim();e.signature.args.push({name:a,value:Number(a),literal:!0})}const k=t((e=>{const t=r(e);return class extends t{static _parseBindings(e,t){const r=[];let k,M,w,V={},N=!1,v=s;for(M=0,w=e.length;M<w;M++){const w=e.charAt(M);switch(v){case s:"{"!==w&&"["!==w||(V={mode:w,dependencies:[],startChar:V.startChar},v=n);break;case n:w===V.mode?(pushLiteral(e,M-1,r,V.startChar),V.startChar=M+1,v=i):(V={},v=s);break;case i:" "!==w&&"\t"!==w&&"\n"!==w&&("!"===w&&(V.negate=!0,V.startChar=M+1),v=o);break;case o:switch(w){case a[V.mode]:v=l;break;case"'":case'"':k=w,v=d;break;case"(":V.signature={methodName:e.substring(V.startChar,M).trim(),args:[],static:!0},V.startChar=M+1,v=b;break;case":":v=c}break;case c:":"===w?(V.customEvent=!0,V.startCharAfterColon=M+1,v=h):v=o;break;case h:w===a[V.mode]&&(v=u);break;case u:if(w===a[V.mode]){V.event=e.substring(V.startCharAfterColon,M-1).trim();storeVariableBinding(r,V,e.substring(V.startChar,V.startCharAfterColon-2).trim(),M),v=s}else v=o;break;case l:if(w===a[V.mode]){storeVariableBinding(r,V,e.substring(V.startChar,M-1).trim(),M),v=s}else v=o;break;case d:"\\"===w?N=!0:w!==k||N?N=!1:v=o;break;case b:switch(w){case")":storeMethodVariable(V,e,M),storeMethod(V,t),V.startChar=M+1,v=C;break;case",":storeMethodVariable(V,e,M),V.startChar=M+1;break;case"'":case'"':k=w,v=m;break;default:w>="0"&&w<="9"||"-"===w?v=g:" "!=w&&"\n"!=w&&(v=p)}break;case m:if("\\"===w)N=!0;else if(w!==k||N)N=!1;else{const t=e.substring(V.startChar,M).replace(/^\s+/,"").substring(1).replace(/&comma;/g,",").replace(/\\(.)/g,"$1");V.signature.args.push({value:t,name:t,literal:!0}),V.startChar=M+1,v=b}break;case g:switch(w){case",":storeMethodNumber(V,e,M),V.startChar=M+1,v=b;break;case")":storeMethodNumber(V,e,M),storeMethod(V,t),v=C;break;default:(w<"0"||w>"9")&&(v=p)}break;case p:switch(w){case",":storeMethodVariable(V,e,M),V.startChar=M+1,v=b;break;case")":storeMethodVariable(V,e,M),storeMethod(V,t),v=C}break;case C:w===a[V.mode]?v=f:" "!==w&&"\t"!==w&&"\n"!==w&&console.warn(`Expected two closing "${a[V.mode]}" for binding "${e}"`);break;case f:w===a[V.mode]?(V.startChar=M+1,r.push(V),v=s):" "!==w&&"\t"!==w&&"\n"!==w&&console.warn(`Expected one closing "${a[V.mode]}" for binding "${e}"`)}}return r.length?(pushLiteral(e,M,r,r[r.length-1].startChar),r):null}}}));export{k as StrictBindingParser};